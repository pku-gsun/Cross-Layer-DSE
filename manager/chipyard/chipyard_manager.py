import abc
import os
import re
from .macros.boom import BoomMacros
from .macros.gemmini import GemminiMacros
from .macros.soc import SocMacros
from .macros.vlsi_flow import VlsiFlow
from manager.common import BaseManager
from utils import if_exist, info, assert_error, read_json, remove, mkdir, execute
from multiprocessing import Pool
import os


class ChipyardManager(BaseManager):
    """
        Chipyard manager generates Verilog codes from Chisel codes.
    """

    def __init__(self, configs: dict) -> None:
        super().__init__(configs)

    @property
    def name(self):
        return "chipyard_manager"
    
    @property
    def chipyard_root(self):
        return self.configs['chipyard_root']

    @property
    def verilator_root(self):
        return os.path.join(self.chipyard_root, 'sims', 'verilator')

    @property
    def vlsi_root(self):
        return os.path.join(self.chipyard_root, 'vlsi')

    @property
    def soc(self) -> str:
        return self.configs['soc_configs']['config_name']
    
    @property
    def verilator_simulator(self):
        """
            The sim executable generated by verilator.
        """
        return os.path.join(self.rundir, 'verilator-simulator')
    
    @property
    def sram_generator_output_json(self):
        """
            The file containing all extra libraries for SRAM.
        """
        return os.path.join(self.rundir, 'sram_generator-output.json')
    
    @property
    def vlsi_finish_flag(self):
        return os.path.join(self.rundir, 'vlsi_finish.flag')
    
    @property
    def verilog_dir(self):
        return os.path.join(self.rundir, 'verilog')

    @property
    def sim_dir(self):
        return os.path.join(self.rundir, 'sims')

    def generate_boom_chisel_codes(self) -> str:
        """
            Generate Chisel codes of the boom config
            Returns: intermediate Chisel code path
        """
        if not ('boom_configs' in self.configs):
            return None

        macros = BoomMacros(self.configs)
        macros.run()
        return macros.chisel_config_path
    
    def generate_gemmini_chisel_codes(self) -> str:
        """
            Generate Chisel codes of the gemmini config
            Returns: intermediate Chisel code path
        """
        if not ('gemmini_configs' in self.configs):
            return None

        macros = GemminiMacros(self.configs)
        macros.run()
        return macros.chisel_config_path

    def generate_soc_chisel_codes(self) -> str:
        """
            Generate Chisel codes of SOC config
            Returns: intermediate Chisel code path
        """
        assert 'soc_configs' in self.configs, assert_error('soc configs not found in chipyard manager!')

        macros = SocMacros(self.configs)
        macros.run()
        return macros.chisel_config_path

    def compile_vlsi(self) -> None:
        """
            Run chipyard vlsi flow to generate verilog files and SRAM tech files
        """
        if 'vlsi_configs' not in self.configs:
            return
        info("Running VLSI flow for SoC configuration %s" % (self.soc))

        vlsi_configs = self.configs['vlsi_configs']
        generated_src_dir = os.path.join(
            self.vlsi_root,
            'generated-src',
            'chipyard.harness.TestHarness.{}'.format(self.soc),
        )
        mkdir(self.verilog_dir)
        syn_f_path = os.path.join(generated_src_dir, 'syn.f')

        def condition():
            return if_exist(self.vlsi_finish_flag)
        
        vlsi_flow = VlsiFlow(self.configs)
        vlsi_flow.run()

        cmd = "cd %s && source ~/.bashrc && source env.sh && " \
            "cd %s && make buildfile " \
            "CONFIG=%s " \
            "ENV_YML=%s " \
            "TECH_CONF=%s " \
            "TOOLS_CONF=%s " \
            "OBJ_DIR=%s && " \
            "cat %s | xargs -I {} cp {} %s && " \
            "touch %s" % (
                self.chipyard_root,
                self.vlsi_root,
                self.soc,
                vlsi_flow.env_yml_path,
                vlsi_flow.tech_conf_path,
                vlsi_flow.tools_conf_path,
                self.rundir,
                syn_f_path,
                self.verilog_dir,
                self.vlsi_finish_flag,
            )
        # time budget: 1 hours
        self.routine_check(3600, cmd, condition, 1)

        # clean
        if vlsi_configs.get('clean_up', True):
            remove(generated_src_dir)


    def compile_verilator(self) -> None:
        """
            Compile verilator simulator
        """
        if 'verilator_configs' not in self.configs:
            return
        info("Compiling Verilator for SoC configuration %s" % (self.soc))
        
        verilator_configs = self.configs['verilator_configs']
        build_verilator_simulator = os.path.join(
            self.verilator_root,
            'simulator-chipyard.harness-{}'.format(self.soc),
        )
        generated_src_dir = os.path.join(
            self.verilator_root,
            'generated-src',
            'chipyard.harness.TestHarness.{}'.format(self.soc),
        )
        
        # Customized test driver always print completed message
        custom_test_driver_file = os.path.join(os.path.dirname(__file__), 'CustomTestDriver.v')

        def condition():
            return if_exist(self.verilator_simulator)
        
        cmd = "cd {}; " \
            "source ~/.bashrc; " \
            "source env.sh; " \
            "cd {}; " \
            "make -j{} " \
            "CONFIG={} " \
            "VERILATOR_THREADS={} "\
            "SIM_FILE_REQS={} " \
            "TB=CustomTestDriver; " \
            "cp {} {}".format(
                self.chipyard_root,
                self.verilator_root,
                verilator_configs.get('build_threads', 1),
                self.soc,
                verilator_configs.get('verilator_threads', 1),
                custom_test_driver_file,
                os.path.join(self.verilator_root, 'simulator-chipyard.harness-{}'.format(self.soc)),
                self.verilator_simulator,
            )

        # time budget: 1 hour
        self.routine_check(3600, cmd, condition, 1)

        # cleanup
        if verilator_configs.get('clean_up', True):
            remove(build_verilator_simulator)
            remove(generated_src_dir)


    def simulate_with_verilator(self) -> None:
        """
            Run verilator simulation
        """
        if 'verilator_configs' not in self.configs:
            return
        info("Running Verilator simulation for SoC configuration %s" % (self.soc))
        
        verilator_configs = self.configs['verilator_configs']
        if_exist(self.verilator_simulator, strict=True)

        mkdir(self.sim_dir)

        # by default use all available workers
        num_workers = verilator_configs.get('num_workers', -1)
        if num_workers == -1:
            num_workers = len(verilator_configs['benchmarks'])

        pool = Pool(num_workers)

        for benchmark_config in verilator_configs['benchmarks']:
            if 'log' not in benchmark_config:
                benchmark_config['log'] = os.path.join(self.sim_dir, f'{benchmark_config["name"]}.log')
            if 'out' not in benchmark_config:
                benchmark_config['out'] = os.path.join(self.sim_dir, f'{benchmark_config["name"]}.out')

            pool.apply_async(self.simulate_single_benchmark_with_verilator, kwds=benchmark_config)

        pool.close()
        pool.join()


    def simulate_single_benchmark_with_verilator(
        self,
        name: str,
        elf: str,
        log: str,
        out: str,
        inputs: list = [],
        options: dict = {},
        force: bool = False,
        extra_sim_flags: str = "",
        verbose: bool = True,
        timeout_cycles: int = 10000000,
    ) -> None:
        
        finish_flag_path = os.path.join(os.path.dirname(out), f'{name}.finish.flag')
        if not force and if_exist(finish_flag_path): return
        
        sim_flags = "+dramsim +dramsim_ini_dir=%s/generators/testchipip/src/main/resources/dramsim2_ini " \
                    "+max_cycles=%d " % (
                        self.chipyard_root,
                        timeout_cycles,
                    )
        verbose_flag = "+verbose" if verbose else ""
        cmd = "%s +permissive %s %s %s +permissive-off %s </dev/null 2>%s | tee %s &&" \
              "touch %s" % (
                    self.verilator_simulator,
                    sim_flags,
                    extra_sim_flags,
                    verbose_flag,
                    elf,
                    out,
                    log,
                    finish_flag_path,
                )
        execute(cmd, verbose=True, wait=True)


    def run_impl(self) -> None:
        boom_chisel_code_path = self.generate_boom_chisel_codes()
        gemmini_chisel_code_path = self.generate_gemmini_chisel_codes()
        soc_chisel_code_path = self.generate_soc_chisel_codes()

        self.compile_vlsi()
        self.compile_verilator()
        self.simulate_with_verilator()

        # clean up intermediate files
        if boom_chisel_code_path: remove(boom_chisel_code_path)
        if gemmini_chisel_code_path: remove(gemmini_chisel_code_path)
        if soc_chisel_code_path: remove(soc_chisel_code_path)


    def get_verilog_files(self) -> list:
        """
            Read out syn.f and return all verilog files
        """
        verilog_files = []
        for root, dirs, files in os.walk(self.verilog_dir):
            for file in files:
                if file.endswith('.v') or file.endswith('.sv'):
                    verilog_files.append(os.path.join(root, file))
        return verilog_files

    def get_sram_extra_libraries(self):
        """
            Read out sram_generator-output.json for extra backend dependencies
        """
        lib_files = set()
        setup_lib_files = set()
        hold_lib_files = set()
        lef_files = set()

        assert if_exist(self.sram_generator_output_json), \
            assert_error('sram_generator-output.json not found in chipyard manager!')
        
        sram_generator_output = read_json(self.sram_generator_output_json)
        for extra_library in sram_generator_output['vlsi.technology.extra_libraries']:
            extra_library = extra_library['library']

            lef_files.add(extra_library['lef_file'])
            if extra_library['corner']['nmos'] == 'fast':
                setup_lib_files.add(extra_library['nldm_liberty_file'])
            elif extra_library['corner']['nmos'] == 'slow':
                hold_lib_files.add(extra_library['nldm_liberty_file'])
            else:
                lib_files.add(extra_library['nldm_liberty_file'])

        return {
            'lib_files': list(lib_files),
            'setup_lib_files': list(setup_lib_files),
            'hold_lib_files': list(hold_lib_files),
            'lef_files': list(lef_files),
        }

    def generate_output_impl(self) -> dict:
        output = {
            'verilog_files': self.get_verilog_files(),
            'extra_libraries': self.get_sram_extra_libraries(),
        }
        
        return output